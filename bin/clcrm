#!/usr/bin/env python
import sys
import datetime
import subprocess
import git
from pathlib import Path
from os import environ

# We use classes more to organize methods, more as namespaces to organize code
# This isn't really meant to be OO code

class CrmEnv:
    def getenv(self,envvar):
        val = environ.get(envvar,None)
        if val == None:
            print('Environment variable not set',envvar)
            sys.exit(1)
        return val

    # Env based paths
    def confdir    (self): return Path( self.getenv('CRM_CONFDIR'))
    def dbdir      (self): return Path( self.getenv('CRM_DBDIR'))
    def cachedir   (self): return Path( self.getenv('CRM_CACHEDIR'))
    def installdir (self): return Path( self.getenv('CRM_INSTALLDIR'))

    # Relative paths
    def vimformsdir  (self): return self.confdir   () / 'vimforms'
    def texformsdir  (self): return self.confdir   () / 'texforms'
    def allregnsfile (self): return self.cachedir  () / 'allregns.otl'
    def indexdir     (self): return self.dbdir     () / 'index'
    def bindir       (self): return self.installdir() / 'bin'
    def vimrc        (self): return self.bindir    () / 'crm_vimrc'

class Confdb:
    def getVimForm(self,name):
        formfile = CrmEnv().vimformsdir() / ( name + '.otl' )
        if not formfile.exists():
            print('Form not found',formfile)
            sys.exit(1)
        return formfile

class Otl:
    def write(self,lines):
        with self.path.open(mode='w') as fp:
            for indent,text in lines: fp.write('\t'*indent + text+'\n')
    def append(self,otl):
        with self.path.open(mode='a') as fp: fp.write(otl.read_text())
    def paginate(self):
        cmd = [ 'less', str(self.path) ]
        subprocess.run(cmd)
    def edit(self):
        cmd = [ 'vim',
            '-c', 'source ' + str(CrmEnv().vimrc()),
            str(self.path) ]
        subprocess.run(cmd)
    def print(self): print(self.path.read_text())
    def __init__(self,path):
        if not path.exists():
            print('Otlutils:write did not find the file',path)
            sys.exit(1)
        self.path = path

class Indexdb:
    def appendRegn(self,regnfile):
        allregnsfile = CrmEnv().allregnsfile()
        if not allregnsfile.exists(): allregnsfile.touch()
        Otl(allregnsfile).append(regnfile)
    def rebuildRegns(self): pass
    def addreg(self,regnfile):
        indexrepo = git.Repo.init(CrmEnv().indexdir())
        indexrepo.index.add(regnfile)
        indexrepo.index.commit("")
        self.appendRegn(regnfile)

class PathUtils:
    def mkdir(self,dirpath): dirpath.mkdir(parents=True,exist_ok=True)

class Reginfo:
    @classmethod
    def newRegno(self): return Reginfo(datetime.datetime.now().strftime("%y%m%d%H%M"))
    def __str__(self): return self.regno
    def yy(self): return self.regno[:2]
    def indxdir(self): return CrmEnv().indexdir() / self.yy()
    def basename(self): return self.regno + '.otl'
    def regnfile(self): return self.indxdir() / self.basename()
    def cachefile(self): return CrmEnv().cachedir() / self.basename()
    def dbdir(self): return CrmEnv().dbdir() / self.yy() / self.regno
    def exists(self): return self.regnfile().exists()
    def edit(self):
        if not self.exists():
            print('Invalid regno',self.regno)
            sys.exit(1)
        Otl(self.regnfile()).edit()
    def __init__(self,regno):
        self.regno = regno

class Cmd:
    @classmethod
    def cmd(cls): return cls.__name__.replace('Cmd_','')
    def usage(self): print('Usage:',self.basecmd,self.cmd(),self._usage)
    def run(self,args): print('Command not implemented:',self.cmd())
    def __init__(self,args):
        if not self.validateCLI(args): self.usage()
        else: self.run(args)
            
class Cmd_help(Cmd):
    _usage = ''
    _helpmsg = 'Print this help'
    def validateCLI(self,args): return len(args) == 0
    def run(self,args):
        print('\nAvailable commands:\n')
        for c in Cmd.cmds.values(): print(' ',c.cmd(),c._usage,'\n   ',c._helpmsg,'\n')

class Cmd_register(Cmd):
    _usage = ''
    _helpmsg = 'Register a new party'
    def validateCLI(self,args): return len(args) == 0
    def run(self,args):
        regno = Reginfo.newRegno()
        regnfile = regno.regnfile()
        if regnfile.exists() :
            print('Registration exists with number',regno)
            print('You are probably trying to register too fast, try after 1 minute')
            sys.exit(1)
        cachefile = regno.cachefile()
        cachefile.touch()
        formname = 'registration'
        form = Confdb().getVimForm(formname)
        otl = Otl(cachefile)
        otl.write([
            (0,formname),
            (1,'Regno'),
            (2,str(regno))
            ])
        otl.append(form)
        otl.edit()
        print('Please review the information:')
        otl.print()
        resp = input('Press y if you want to proceed with adding this registration: ')
        if resp == 'y' :
            PathUtils().mkdir(regnfile.parents[0])
            cachefile.rename(regnfile)
            dbdir = regno.dbdir()
            git.Repo.init(dbdir)
            Indexdb().addreg(regnfile)
            print('Registration added')
        else :
            print('Registration canceled')
            cachefile.unlink()

class Cmd_modreg(Cmd):
    _usage = '<regno>'
    _helpmsg = 'Modify a registratered entry'
    def validateCLI(self,args): return len(args) == 1
    def run(self,args):
        Reginfo(args[0]).edit()

class Cmd_search(Cmd):
    _usage = ''
    _helpmsg = 'Search registered party'
    def validateCLI(self,args): return len(args) == 0
    def run(self,args): Otl(CrmEnv().allregnsfile()).paginate()

class Cmd_meet(Cmd):
    _usage = '<regno>'
    _helpmsg = 'Record / edit interaction'
    def validateCLI(self,args): return len(args) == 1

class Cmd_hist(Cmd):
    _usage = '<regno>'
    _helpmsg = 'View interaction history'
    def validateCLI(self,args): return len(args) == 1

class CmdHandler:
    def __init__(self,args):
        Cmd.basecmd = args[0]
        subcmdargs = args[1:]
        Cmd.cmds = { c.cmd() : c for c in Cmd.__subclasses__() }
        cmd = 'help' if len(subcmdargs) == 0 else subcmdargs[0]
        if cmd not in Cmd.cmds:
            print('No such command:',cmd)
            cmd = 'help'
        subargs = subcmdargs[1:]
        cmd = Cmd.cmds[cmd](subargs)

if __name__ == '__main__': CmdHandler(sys.argv)
