#!/usr/bin/env python
import sys
import os
import datetime
import subprocess
import git
import cmd
import readline
from pathlib import Path
from os import environ

# We use classes more to organize methods, more as namespaces to organize code
# This isn't really meant to be OO code

CMDHISTLEN = 100

class CrmEnv:
    def getenv(self,envvar):
        val = environ.get(envvar,None)
        if val == None: raise Exception('Environment variable not set '+envvar)
        return val

    # Env based paths
    def confdir    (self): return Path( self.getenv('CRM_CONFDIR'))
    def dbdir      (self): return Path( self.getenv('CRM_DBDIR'))
    def cachedir   (self): return Path( self.getenv('CRM_CACHEDIR'))
    def installdir (self): return Path( self.getenv('CRM_INSTALLDIR'))

    # Relative paths
    def vimformsdir  (self): return self.confdir   () / 'vimforms'
    def texformsdir  (self): return self.confdir   () / 'texforms'
    def allregnsfile (self): return self.cachedir  () / 'allregns.otl'
    def indexdir     (self): return self.dbdir     () / 'index'
    def bindir       (self): return self.installdir() / 'bin'
    def vimrc        (self): return self.bindir    () / 'crm_vimrc'
    def cmdhist      (self): return self.cachedir  () / 'cmdhist'

    # subprocess env
    def subpenv(self): return { **environ, **{
        'CRM_VIMFORMSDIR' : self.vimformsdir(),
        'CRM_TEXFORMSDIR' : self.texformsdir(),
        }}

class TimeUtils:
    regfmt = '%y%m%d%H%M'
    datefmt = '%y%m%d'

class Otl:
    def write(self,lines):
        with self.path.open(mode='w') as fp:
            for indent,text in lines: fp.write('\t'*indent + text+'\n')
    def append(self,otl):
        with self.path.open(mode='a') as fp: fp.write(otl.read_text())
    def paginate(self):
        cmd = [ 'less', str(self.path) ]
        subprocess.run(cmd)
    def view(self):
        cmd = [ 'vim', '-R',
            '-c', 'source ' + str(CrmEnv().vimrc()),
            str(self.path) ]
        subprocess.run(cmd)
    def edit(self):
        crmenv = CrmEnv()
        cmd = [ 'vim',
            '-c', 'let g:vimformsdir="' + str(crmenv.vimformsdir()) + '"',
            '-c', 'source ' + str(crmenv.vimrc()),
            str(self.path) ]
        subprocess.run(cmd,env=crmenv.subpenv())
    def delete(self): self.path.unlink()
    def print(self): print(self.path.read_text())
    def __init__(self,path):
        if not path.exists():
            raise Exception('Otlutils:write did not find the file '+str(path))
        self.path = path

class Confdb:
    def getVimForm(self,name):
        formfile = CrmEnv().vimformsdir() / ( name + '.otl' )
        if not formfile.exists():
            raise Exception('Form not found '+str(formfile))
        return formfile

class Indexdb:
    def appendRegn(self,regnfile):
        allregnsfile = CrmEnv().allregnsfile()
        if not allregnsfile.exists(): allregnsfile.touch()
        Otl(allregnsfile).append(regnfile)
    def rebuildRegns(self):
        allregnsOtl = Otl( CrmEnv().allregnsfile() )
        allregnsOtl.write([])
        for r in sorted(CrmEnv().indexdir().glob('*/*.otl')): allregnsOtl.append(r)
    def addreg(self,regnfile):
        indexrepo = git.Repo.init(CrmEnv().indexdir())
        indexrepo.index.add(regnfile)
        indexrepo.index.commit('')
        self.appendRegn(regnfile)

class Fifo:
    def delete(self): self.path.unlink()
    def create(self): os.mkfifo(self.path)
    def readline(self):
        with open(self.path) as fp: return fp.readline()
    def writeline(self,line):
        with open(self.path,'w') as fp:
            fp.write(line+'\n')
            fp.flush()
    def __init__(self,path): self.path = path

class Partydb:
    def init(self): git.Repo.init( self.reginfo.dbdir() )
    def validDate(self,datestr):
        try: dateobj = datetime.datetime.strptime(datestr,TimeUtils.datefmt)
        except: return False
        return self.reginfo.regdt() <= dateobj and dateobj <= datetime.datetime.now()
    def histfile(self): return CrmEnv().cachedir() / self.reginfo.basename()
    def genhist(self):
        histfile = self.histfile()
        histfile.touch()
        histOtl = Otl( histfile )
        histOtl.write([])
        for n in sorted(self.reginfo.dbdir().glob('*/notes.otl'),reverse=True):
            histOtl.append(n)
        return histOtl
    def notesfile(self,datestr=None,create=False):
        if datestr != None:
            if not self.validDate(datestr):
                raise Exception('Invalid date '+datestr)
        else: datestr = datetime.datetime.today().strftime(TimeUtils.datefmt)
        notesdir = self.reginfo.dbdir()/datestr
        notesfile = notesdir/'notes.otl'
        if create and not notesfile.exists():
            PathUtils().mkdir(notesdir)
            notesfile.touch()
            self.gitrepoIndex().add(notesfile)
        return notesfile
    def gitrepoIndex(self): return git.Repo(self.reginfo.dbdir()).index
    def commit(self): self.gitrepoIndex().commit('')
    def __init__(self,reginfo): self.reginfo = reginfo

class PathUtils:
    def mkdir(self,dirpath): dirpath.mkdir(parents=True,exist_ok=True)

class Reginfo:
    @classmethod
    def newRegno(self): return Reginfo(datetime.datetime.now().strftime(TimeUtils.regfmt))
    def __str__(self): return self.regno
    def yy(self): return self.regno[:2]
    def yymmdd(self): return self.regno[:6]
    def indxdir(self): return CrmEnv().indexdir() / self.yy()
    def basename(self): return self.regno + '.otl'
    def regnfile(self): return self.indxdir() / self.basename()
    def cachefile(self): return CrmEnv().cachedir() / self.basename()
    def dbdir(self): return CrmEnv().dbdir() / self.yy() / self.regno
    def exists(self): return self.regnfile().exists()
    def regdt(self): return datetime.datetime.strptime(self.yymmdd(),TimeUtils.datefmt)
    def edit(self):
        if not self.exists():
            raise Exception('Invalid regno '+self.regno)
        Otl(self.regnfile()).edit()
    def __init__(self,regno):
        self.regno = regno

class Cmd:
    @classmethod
    def cmd(cls): return cls.__name__.replace('Cmd_','')
    def usage(self): print('Usage:',self.cmd(),self._usage)
    def run(self,args): print('Command not implemented:',self.cmd())
    def __call__(self,arg):
        args = arg.split()
        if self.validateCLI(args):
            try: self.run(args)
            except Exception as e: print('Error:',e)
        else : self.usage()
        return False # to continue cmd main loop
    def __init__(self):
        self.__doc__ = self.cmd() + ' ' + self._usage + ' : ' + self._helpmsg

class Cmd_register(Cmd):
    _usage = ''
    _helpmsg = 'Register a new party'
    def validateCLI(self,args): return len(args) == 0
    def run(self,args):
        regno = Reginfo.newRegno()
        regnfile = regno.regnfile()
        if regnfile.exists() :
            raise Exception('Registration exists with number ' + regno +
                ' You are probably trying to register too fast, try after 1 minute')
        cachefile = regno.cachefile()
        cachefile.touch()
        formname = 'registration'
        form = Confdb().getVimForm(formname)
        otl = Otl(cachefile)
        otl.write([
            (0,formname),
            (1,'Regno'),
            (2,str(regno))
            ])
        otl.append(form)
        otl.edit()
        print('Please review the information:')
        otl.print()
        resp = input('Press y if you want to proceed with adding this registration: ')
        if resp == 'y' :
            PathUtils().mkdir(regnfile.parents[0])
            cachefile.rename(regnfile)
            Partydb(regno).init()
            Indexdb().addreg(regnfile)
            print('Registration added')
        else :
            print('Registration canceled')
            cachefile.unlink()

class Cmd_modreg(Cmd):
    _usage = '<regno>'
    _helpmsg = 'Modify a registratered entry'
    def validateCLI(self,args): return len(args) == 1
    def run(self,args):
        Reginfo(args[0]).edit()
        Indexdb().rebuildRegns()

class Cmd_search(Cmd):
    _usage = ''
    _helpmsg = 'Search registered party'
    def validateCLI(self,args): return len(args) == 0
    def run(self,args): Otl(CrmEnv().allregnsfile()).paginate()

class Cmd_meet(Cmd):
    _usage = '<regno> [yymmdd]'
    _helpmsg = 'Record / edit interaction on today or given date in yymmdd form'
    def validateCLI(self,args): return len(args) == 1 or len(args) == 2
    def run(self,args):
        partydb = Partydb( Reginfo(args[0]) )
        datestr = args[1] if len(args) == 2 else None
        Otl( partydb.notesfile(datestr,True) ).edit()
        partydb.commit()

class Cmd_hist(Cmd):
    _usage = '<regno>'
    _helpmsg = 'View interaction history'
    def validateCLI(self,args): return len(args) == 1
    def run(self,args):
        partydb = Partydb( Reginfo(args[0]) )
        histOtl = partydb.genhist()
        histOtl.view()
        histOtl.delete()

class CrmCLI(cmd.Cmd):
    intro = "Welcome to clcrm. Type help or ? to list commands, Ctrl-D or EOF to exit."
    prompt = 'clcrm> '
    def do_EOF(self,args):
        'exit clcrm'
        return True
    def preloop(self):
        self.cmdhist = CrmEnv().cmdhist()
        self.cmdhist.touch()
        readline.read_history_file(self.cmdhist)
        readline.set_history_length(CMDHISTLEN)
    def postloop(self): readline.write_history_file(self.cmdhist)
    def __init__(self):
        super().__init__()
        for c in Cmd.__subclasses__() :
            cinst = c()
            fname = f'do_{c.cmd()}'
            setattr(self.__class__,fname,cinst)

if __name__ == '__main__':
    cli = CrmCLI()
    if len(sys.argv) > 1:
        cmd = sys.argv[1]
        handler = f'do_{cmd}'
        if hasattr(cli,handler) and callable(getattr(cli,handler)): getattr(cli,handler)(sys.argv[2:])
        else:
            print('Invalid command:',cmd,'Type',sys.argv[0],'help to see available commands')
            sys.exit(1)
    else: cli.cmdloop()
